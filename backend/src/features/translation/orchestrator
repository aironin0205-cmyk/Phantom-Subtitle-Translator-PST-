// ===== PRODUCTION-READY TRANSLATION ORCHESTRATOR =====
// This class contains the core business logic for the translation feature.
// It orchestrates calls to various agents and the data repository to perform complex tasks.

// ===== IMPORTS & DEPENDENCIES =====
import * as agents from './agents.js';
import { parseSrt, toSrtString } from '#core/srtParser.js';

// ===== CORE BUSINESS LOGIC =====
/**
 * Orchestrates the multi-agent process for generating and executing translations.
 */
export class TranslationOrchestrator {
  /**
   * @param {object} dependencies - The dependencies for this orchestrator.
   * @param {import('./repository.js').TranslationRepository} dependencies.repository - The data access layer.
   * @param {object} dependencies.logger - The Pino logger instance.
   */
  constructor({ repository, logger }) {
    this.repository = repository;
    this.logger = logger;
    // Note: For even more advanced DI, the agents could also be injected.
    // For now, importing them directly is a reasonable approach.
    this.agents = agents;
  }

  /**
   * Orchestrates the creation of a translation blueprint.
   * @param {string} subtitleContent - The original SRT or plain text content.
   * @param {object} settings - The user-defined settings for the translation.
   * @returns {Promise<{jobId: string, blueprint: object}>} The created job ID and blueprint.
   */
  async generateTranslationBlueprint(subtitleContent, settings) {
    this.logger.info("--- Orchestrator: Starting Stateful Blueprint Generation ---");

    this.logger.info("Creating translation job record...");
    const jobResult = await this.repository.createJob({ subtitleContent, settings });
    const jobId = jobResult.insertedId.toString();
    this.logger.info({ jobId }, "Translation job record created successfully.");

    const isSrtMode = subtitleContent.includes('-->');
    const textToAnalyze = isSrtMode 
      ? parseSrt(subtitleContent).map(line => line.text).join('\n')
      : subtitleContent;

    const { keywords } = await this.agents.agent_extractKeywords(textToAnalyze);
    if (!keywords || !Array.isArray(keywords)) {
      throw new Error("Agent 1 (Extract Keywords) returned invalid data.");
    }

    const { grounded_keywords } = await this.agents.agent_groundTranslations(keywords);
    if (!grounded_keywords || !Array.isArray(grounded_keywords)) {
      throw new Error("Agent 2 (Ground Translations) returned invalid data.");
    }

    const blueprint = await this.agents.agent_assembleBlueprint(textToAnalyze, settings.tone, grounded_keywords);
    if (!blueprint) {
      throw new Error("Agent 3 (Assemble Blueprint) returned invalid data.");
    }
    
    this.logger.info({ jobId }, "Saving generated blueprint to database...");
    await this.repository.saveBlueprint(jobId, blueprint);
    this.logger.info({ jobId }, "Blueprint saved successfully.");

    if (blueprint.glossary?.length > 0) {
      this.logger.info({ jobId, termCount: blueprint.glossary.length }, "Upserting glossary terms to vector store.");
      // Fire-and-forget for non-critical background task.
      this.repository.upsertGlossaryVectors(jobId, blueprint.glossary)
        .catch(err => this.logger.error({ err, jobId }, "Non-critical error: Failed to upsert glossary vectors."));
    }
    
    this.logger.info({ jobId }, "--- Orchestrator: Blueprint Generation Complete ---");
    return { jobId, blueprint };
  }

  /**
   * Orchestrates the full translation of an SRT file based on an approved blueprint.
   * @param {string} jobId - The ID of the job to execute.
   * @param {object} confirmedBlueprint - The user-approved (or modified) blueprint.
   * @param {object} settings - The user-defined settings for the translation.
   * @returns {Promise<object>} An object containing the final SRT and any sync suggestions.
   */
  async executeTranslationChain(jobId, confirmedBlueprint, settings) {
    this.logger.info({ jobId }, "--- Orchestrator: Starting Stateful Translation Chain ---");

    // --- Step 1: Fetch original job data ---
    // Note: This requires a new method in our repository.
    // We'll add this in the next step.
    const job = await this.repository.getJobById(jobId);
    if (!job) {
      this.logger.error({ jobId }, "executeTranslationChain failed: Job not found.");
      throw new Error(`Job with ID ${jobId} not found.`); // Or a custom NotFoundError
    }
    
    const srtLines = parseSrt(job.subtitleContent);
    
    // --- Step 2: Batch processing logic ---
    const batches = [];
    const LINES_PER_BATCH = 25; // This could be moved to config
    for (let i = 0; i < srtLines.length; i += LINES_PER_BATCH) {
        batches.push(srtLines.slice(i, i + LINES_PER_BATCH));
    }
    
    // Placeholder for the full translation chain which would iterate through batches,
    // calling transcreate, edit, and qa agents.
    this.logger.info({ jobId, batchCount: batches.length }, "Beginning batch processing (placeholder).");
    
    // As a placeholder, we'll create a dummy result.
    const finalResult = { 
        finalSrt: "Translation complete (full chain placeholder).", 
        syncSuggestions: [] 
    };
    
    await this.repository.saveFinalSrt(jobId, finalResult.finalSrt);
    this.logger.info({ jobId }, "Final SRT saved to job record.");
    
    return finalResult;
  }
}

// ===== PRODUCTION-READY TRANSLATION ORCHESTRATOR =====
// This class contains the core business logic for the translation feature.
// It orchestrates calls to the AgentService and the Repository.

// ===== IMPORTS & DEPENDENCIES =====
import { parseSrt } from '#core/srtParser.js';

// ===== CORE BUSINESS LOGIC =====
/**
 * Orchestrates the multi-agent process for generating and executing translations.
 */
export class TranslationOrchestrator {
  /**
   * @param {object} dependencies - The dependencies for this orchestrator.
   * @param {import('./repository.js').TranslationRepository} dependencies.repository
   * @param {import('./agents.js').AgentService} dependencies.agentService
   * @param {object} dependencies.logger
   */
  constructor({ repository, agentService, logger }) {
    this.repository = repository;
    this.agentService = agentService;
    this.logger = logger;
  }

  /**
   * Orchestrates the creation of a translation blueprint.
   * @param {string} subtitleContent - The original SRT or plain text content.
   * @param {object} settings - The user-defined settings for the translation.
   * @returns {Promise<{jobId: string, blueprint: object}>} The created job ID and blueprint.
   */
  async generateTranslationBlueprint(subtitleContent, settings) {
    this.logger.info("--- Orchestrator: Starting Stateful Blueprint Generation ---");

    const jobResult = await this.repository.createJob({ subtitleContent, settings });
    const jobId = jobResult.insertedId.toString();
    this.logger.info({ jobId }, "Translation job record created successfully.");

    const isSrtMode = subtitleContent.includes('-->');
    const textToAnalyze = isSrtMode 
      ? parseSrt(subtitleContent).map(line => line.text).join('\n')
      // NOTE: Consider adding a max character limit check for plain text to prevent huge API calls.
      : subtitleContent;

    // Use the injected agentService for the agent chain
    const { keywords } = await this.agentService.extractKeywords(textToAnalyze);
    if (!keywords) throw new Error("Agent [extractKeywords] failed to return data.");

    const { grounded_keywords } = await this.agentService.groundTranslations(keywords);
    if (!grounded_keywords) throw new Error("Agent [groundTranslations] failed to return data.");

    const blueprint = await this.agentService.assembleBlueprint(textToAnalyze, settings.tone, grounded_keywords);
    if (!blueprint) throw new Error("Agent [assembleBlueprint] failed to return data.");
    
    await this.repository.saveBlueprint(jobId, blueprint);
    this.logger.info({ jobId }, "Blueprint saved successfully.");

    if (blueprint.glossary?.length > 0) {
      this.logger.info({ jobId, termCount: blueprint.glossary.length }, "Upserting glossary terms to vector store.");
      // Fire-and-forget for non-critical background task.
      this.repository.upsertGlossaryVectors(jobId, blueprint.glossary)
        .catch(err => this.logger.error({ err, jobId }, "Non-critical error: Failed to upsert glossary vectors."));
    }
    
    this.logger.info({ jobId }, "--- Orchestrator: Blueprint Generation Complete ---");
    return { jobId, blueprint };
  }

  /**
   * Orchestrates the full translation of an SRT file based on an approved blueprint.
   * @param {string} jobId - The ID of the job to execute.
   * @param {object} confirmedBlueprint - The user-approved (or modified) blueprint.
   * @param {object} settings - The user-defined settings for the translation.
   * @returns {Promise<object>} An object containing the final SRT and any sync suggestions.
   */
  async executeTranslationChain(jobId, confirmedBlueprint, settings) {
    this.logger.info({ jobId }, "--- Orchestrator: Starting Stateful Translation Chain ---");

    const job = await this.repository.getJobById(jobId);
    if (!job) {
      this.logger.error({ jobId }, "executeTranslationChain failed: Job not found.");
      // In a real app, you might throw a specific NotFoundError class
      throw new Error(`Job with ID ${jobId} not found.`);
    }
    
    const srtLines = parseSrt(job.subtitleContent);
    const LINES_PER_BATCH = 25; // This could also be moved to config
    const batches = [];
    for (let i = 0; i < srtLines.length; i += LINES_PER_BATCH) {
        batches.push(srtLines.slice(i, i + LINES_PER_BATCH));
    }
    
    this.logger.info({ jobId, batchCount: batches.length }, "Beginning batch processing.");
    
    // This is a simplified sequential chain. A more advanced implementation might run batches in parallel.
    let translatedLines = [];
    let previousContext = "This is the beginning of the script.";

    for (const batch of batches) {
      // The full agent chain per batch
      const transcreated = await this.agentService.transcreateBatch(batch, previousContext, confirmedBlueprint, settings.tone);
      const edited = await this.agentService.editBatch(batch, transcreated, confirmedBlueprint, settings.tone);
      const qa_approved = await this.agentService.qaBatch(batch, edited, confirmedBlueprint, settings.tone);
      const final_batch = await this.agentService.phantomSync(batch, qa_approved);

      const finalLines = final_batch.split('\n');
      translatedLines.push(...finalLines);

      // Update context for the next batch
      previousContext = `The last few lines were: "${finalLines.slice(-2).join(' ')}"`;
    }
    
    // Reassemble the final SRT
    const finalSrtObject = srtLines.map((line, index) => ({
      ...line,
      text: translatedLines[index] || line.text, // Fallback to original if something went wrong
    }));
    
    const finalSrtString = toSrtString(finalSrtObject);
    
    await this.repository.saveFinalSrt(jobId, finalSrtString);
    this.logger.info({ jobId }, "Final SRT saved to job record.");
    
    // In the future, you could extract sync suggestions here to return to the user.
    return { finalSrt: finalSrtString, syncSuggestions: [] };
  }
}

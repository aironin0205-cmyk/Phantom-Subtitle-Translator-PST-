// ===== IMPORTS & DEPENDENCIES =====
import {
  agent_extractKeywords,
  agent_groundTranslations,
  agent_assembleBlueprint,
  agent_transcreateBatch,
  agent_editBatch,
  agent_qaBatch,
  agent_phantomSync
} from './agents.js';
import { parseSrt, toSrtString } from '#core/srtParser.js';

// ===== CONFIGURATION & CONSTANTS =====
const LINES_PER_BATCH = 25; // A configurable constant for batch size
const PHANTOM_SYNC_PREFIX = '[PS Sync:'; // Centralized constant for maintainability

// ===== CORE BUSINESS LOGIC =====
/**
 * Orchestrates the Phase 1 analysis to generate the interactive blueprint.
 * @param {import('fastify').FastifyLoggerInstance} logger - The logger instance from the request.
 * @param {string} subtitleContent The raw SRT or text content.
 * @param {object} settings User-defined settings, like tone.
 * @returns {Promise<object>} The generated blueprint JSON.
 */
export async function generateTranslationBlueprint(logger, subtitleContent, settings) {
  logger.info("--- Orchestrator: Starting Blueprint Generation ---");

  const isSrtMode = subtitleContent.includes('-->');
  const textToAnalyze = isSrtMode 
    ? parseSrt(subtitleContent).map(line => line.text).join('\n')
    : subtitleContent;

  // Agent 1: Extract Keywords
  logger.info("Orchestrator: Calling Agent 1 (Extract Keywords)...");
  const keywordsResult = await agent_extractKeywords(textToAnalyze);
  if (!keywordsResult || !Array.isArray(keywordsResult.keywords)) {
      throw new Error("Agent 1 (Extract Keywords) failed to return a valid keywords array.");
  }
  const { keywords } = keywordsResult;

  if (keywords.length === 0) {
      logger.warn("Orchestrator: No keywords found by agent. Proceeding with a basic blueprint.");
  }

  // Agent 2: Ground Translations
  logger.info({ keywordCount: keywords.length }, "Orchestrator: Calling Agent 2 (Ground Translations)...");
  const groundedResult = await agent_groundTranslations(keywords);
  if (!groundedResult || !Array.isArray(groundedResult.grounded_keywords)) {
    throw new Error("Agent 2 (Ground Translations) failed to return a valid grounded_keywords array.");
  }
  const { grounded_keywords } = groundedResult;

  // Agent 3: Assemble the final blueprint
  logger.info("Orchestrator: Calling Agent 3 (Assemble Blueprint)...");
  const blueprint = await agent_assembleBlueprint(textToAnalyze, settings.tone, grounded_keywords);
  if (!blueprint) {
    throw new Error("Agent 3 (Assemble Blueprint) failed to return a valid blueprint object.");
  }
  
  logger.info("--- Orchestrator: Blueprint Generation Complete ---");
  return blueprint;
}

/**
 * Orchestrates the Phase 2 translation pipeline after the user confirms the blueprint.
 * @param {import('fastify').FastifyLoggerInstance} logger - The logger instance from the request.
 * @param {string} subtitleContent The original raw SRT content.
 * @param {object} settings User-defined settings.
 * @param {object} confirmedBlueprint The user-approved (and possibly modified) blueprint.
 * @returns {Promise<object>} An object containing the final SRT string and any sync suggestions.
 */
export async function executeTranslationChain(logger, subtitleContent, settings, confirmedBlueprint) {
  logger.info("--- Orchestrator: Starting Post-Blueprint Translation Chain ---");
  const srtLines = parseSrt(subtitleContent);

  const batches = [];
  for (let i = 0; i < srtLines.length; i += LINES_PER_BATCH) {
      batches.push(srtLines.slice(i, i + LINES_PER_BATCH));
  }
  
  logger.info({ lineCount: srtLines.length, batchCount: batches.length }, "Subtitle content batched for processing.");

  let finalTranslatedSrtLines = [];
  let syncSuggestions = [];
  let previousContext = ''; // Context from the previously translated batch

  for (let i = 0; i < batches.length; i++) {
    const batch = batches[i];
    const logContext = { batchNum: i + 1, totalBatches: batches.length };
    logger.info(logContext, `Orchestrator: Processing Batch...`);

    // The sequential chain of agents for each batch
    const initialTranslation = await agent_transcreateBatch(batch, previousContext, confirmedBlueprint, settings.tone);
    const editedTranslation = await agent_editBatch(batch, initialTranslation, confirmedBlueprint, settings.tone);
    const qaTranslation = await agent_qaBatch(batch, editedTranslation, confirmedBlueprint, settings.tone);
    const syncedTranslationText = await agent_phantomSync(batch, qaTranslation);

    if (typeof syncedTranslationText !== 'string') {
        logger.error({ ...logContext, received: syncedTranslationText }, "Phantom Sync agent did not return a string. Skipping batch.");
        continue; // Skip this batch to prevent crashing
    }

    // Process the final output for this batch
    const syncedLines = syncedTranslationText.trim().split('\n');
    for (let j = 0; j < batch.length; j++) {
        if (syncedLines[j]) {
            const translatedLine = { ...batch[j], translatedText: syncedLines[j] };
            finalTranslatedSrtLines.push(translatedLine);
            
            if (syncedLines[j].includes(PHANTOM_SYNC_PREFIX)) {
                syncSuggestions.push({
                    sequence: batch[j].sequence,
                    suggestion: syncedLines[j]
                });
            }
        }
    }
    // Update the context for the next batch to ensure smooth transitions.
    previousContext = finalTranslatedSrtLines.slice(-5).map(l => l.translatedText).join('\n');
  }

  logger.info("--- Orchestrator: Translation Chain Complete ---");
  return {
      finalSrt: toSrtString(finalTranslatedSrtLines),
      syncSuggestions: syncSuggestions
  };
}

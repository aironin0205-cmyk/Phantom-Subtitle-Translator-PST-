// ===== DEVELOPMENT/DEBUG TRANSLATION ORCHESTRATOR =====
// This version is refactored for end-to-end observability, robust error handling,
// and a more performant, reliable batch processing implementation.

// ===== IMPORTS & DEPENDENCIES =====
import { parseSrt, toSrtString } from '#core/srtParser.js';
import { NotFoundError } from '#utils/errors.js';
import { runInBackground } from '#utils/async.js';

// ===== CORE BUSINESS LOGIC =====
export class TranslationOrchestrator {
  constructor({ repository, agentService, logger }) {
    this.repository = repository;
    this.agentService = agentService;
    this.logger = logger; // This is the GLOBAL logger, used only if no contextual logger is passed.
  }

  /**
   * Orchestrates the creation of a translation blueprint.
   * @param {string} subtitleContent - The original SRT or plain text content.
   * @param {object} settings - The user-defined settings for the translation.
   * @param {object} logger - The request-specific, contextual logger with traceId.
   * @returns {Promise<{jobId: string, blueprint: object}>}
   */
  async generateTranslationBlueprint(subtitleContent, settings, logger) {
    // If a contextual logger isn't passed, fall back to the global one.
    // This makes the class usable in non-request contexts (e.g., test suites, cron jobs).
    const log = logger || this.logger;
    log.info("--- Orchestrator: Starting Blueprint Generation ---");

    const jobResult = await this.repository.createJob({ subtitleContent, settings }, log);
    const jobId = jobResult.insertedId.toString();
    log.info({ jobId }, "Translation job record created.");

    const isSrtMode = subtitleContent.includes('-->');
    const textToAnalyze = isSrtMode
      ? parseSrt(subtitleContent).map(line => line.text).join('\n')
      : subtitleContent;

    // The agent service is now expected to throw an error on failure. No more `if (!result)` checks.
    const keywords = await this.agentService.extractKeywords(textToAnalyze, log);
    const groundedKeywords = await this.agentService.groundTranslations(keywords, log);
    const blueprint = await this.agentService.assembleBlueprint(textToAnalyze, settings.tone, groundedKeywords, log);
    
    await this.repository.saveBlueprint(jobId, blueprint, log);
    log.info({ jobId }, "Blueprint saved successfully.");

    if (blueprint.glossary?.length > 0) {
      log.info({ jobId, termCount: blueprint.glossary.length }, "Scheduling glossary upsert to vector store.");
      // Use our new utility for cleaner, more explicit background tasks.
      runInBackground(
        () => this.repository.upsertGlossaryVectors(jobId, blueprint.glossary, log),
        log,
        `UpsertGlossaryVectors for Job ${jobId}`
      );
    }
    
    log.info({ jobId }, "--- Orchestrator: Blueprint Generation Complete ---");
    return { jobId, blueprint };
  }

  /**
   * Orchestrates the full translation of an SRT file using parallel batch processing.
   * @param {string} jobId - The ID of the job to execute.
   * @param {object} confirmedBlueprint - The user-approved blueprint.
   * @param {object} settings - The user-defined settings for the translation.
   * @param {object} logger - The request-specific, contextual logger.
   * @returns {Promise<{finalSrt: string, syncSuggestions: Array}>}
   */
  async executeTranslationChain(jobId, confirmedBlueprint, settings, logger) {
    const log = logger || this.logger;
    log.info({ jobId }, "--- Orchestrator: Starting Translation Chain Execution ---");

    const job = await this.repository.getJobById(jobId, log);
    if (!job) {
      // Throw a specific, actionable error that our global handler understands.
      throw new NotFoundError(`Job with ID ${jobId} not found.`);
    }
    
    const srtLines = parseSrt(job.subtitleContent);
    const BATCH_SIZE = 25; // This could be moved to config
    const batches = [];
    for (let i = 0; i < srtLines.length; i += BATCH_SIZE) {
        batches.push(srtLines.slice(i, i + BATCH_SIZE));
    }
    log.info({ jobId, batchCount: batches.length, batchSize: BATCH_SIZE }, "Subtitle content split into batches.");

    // --- Performant & Reliable Parallel Processing ---
    const CONCURRENT_BATCHES = 4; // Process up to 4 batches in parallel to improve speed.
    const allTranslatedBatches = [];
    
    for (let i = 0; i < batches.length; i += CONCURRENT_BATCHES) {
      const chunk = batches.slice(i, i + CONCURRENT_BATCHES);
      log.info({ jobId, chunkIndex: i / CONCURRENT_BATCHES, chunkCount: chunk.length }, `Processing chunk of ${chunk.length} batches.`);
      
      const chunkPromises = chunk.map(batch => 
        this._processSingleBatch(batch, confirmedBlueprint, settings, log)
      );
      
      const processedChunks = await Promise.all(chunkPromises);
      allTranslatedBatches.push(...processedChunks);
    }
    
    // --- Final Assembly ---
    // Flatten the array of arrays into a single array of translated lines.
    const translatedLines = allTranslatedBatches.flat();
    
    const finalSrtObject = srtLines.map((line, index) => ({
      ...line,
      // The contract now guarantees translatedLines is an array of strings.
      text: translatedLines[index] || line.text,
    }));
    
    const finalSrtString = toSrtString(finalSrtObject);
    
    await this.repository.saveFinalSrt(jobId, finalSrtString, log);
    log.info({ jobId }, "Final SRT saved to job record.");
    
    return { finalSrt: finalSrtString, syncSuggestions: [] };
  }

  /**
   * Private helper method to process a single batch through the full agent chain.
   * Its contract is to return an array of translated text strings of the same length as the input batch.
   * @private
   */
  async _processSingleBatch(batch, blueprint, settings, logger) {
    // A real implementation would need to manage context between batches. For simplicity, we omit it here.
    const previousContext = "Some context from previous batch...";

    // We expect each agent to return a structured response.
    const transcreated = await this.agentService.transcreateBatch(batch, previousContext, blueprint, settings.tone, logger);
    const edited = await this.agentService.editBatch(batch, transcreated, blueprint, settings.tone, logger);
    const qaApproved = await this.agentService.qaBatch(batch, edited, blueprint, settings.tone, logger);
    const finalBatch = await this.agentService.phantomSync(batch, qaApproved, logger);

    // This is a critical contract: the final agent must return an array of strings
    // with the exact same number of elements as the input batch.
    if (finalBatch.length !== batch.length) {
      logger.error({ 
        expected: batch.length, 
        received: finalBatch.length, 
        sequences: batch.map(l => l.sequence).join(',')
      }, "FATAL BATCH MISMATCH: Agent returned a different number of lines than expected.");
      // Fallback to original text to prevent corruption of the final SRT file.
      return batch.map(line => line.text);
    }

    return finalBatch;
  }
}
